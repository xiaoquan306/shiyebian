/**
 * @file app5.c
 *
 * @date Created on: 2016/01/18
 * @author Author: DATT JAPAN Inc.
 * @version 1.1
 * @brief Exif APP5領域作成・解析用ソースコード
 */

#include <stdlib.h>
#include <string.h>

#include "app5.h"
#include "exif.h"

/*!
@name APP5 セグメント RMETA 定義サイズに関する定義
@{
*/
#define BYTE_SIZE_RMETA_DATA_OFFSET            ((size_t)2)     /*!< @brief メタデータ内のヘッダ～データ間オフセット定義のバイト数 */
#define BYTE_SIZE_RMETA_ENTRY_COUNT_VALUE      ((size_t)2)     /*!< @brief メタデータ内エントリ数定義のバイト数 */
#define BYTE_SIZE_RMETA_CHARACTER_CODE         ((size_t)8)     /*!< @brief メタデータ内文字コード定義のバイト数 */
#define BYTE_SIZE_RMETA_ITEM_ID                ((size_t)2)     /*!< @brief メタデータ ID 定義のバイト数 */
#define BYTE_SIZE_RMETA_ITEM_SIZE              ((size_t)2)     /*!< @brief メタデータ領域サイズ定義のバイト数 */
#define BYTE_SIZE_RMETA_IDENTIFIER_SIZE        ((size_t)6)     /*!< @brief APP5 RMETA 識別子のバイト数 */
/*!
@}

@name APP5 セグメント定義サイズに関する定数
@{
*/
static const size_t BYTE_SIZE_APP5_META_VERSION       = 2;     /*!< @brief APP5 セグメント内メタバージョン定義のバイト数 */
static const size_t BYTE_SIZE_APP5_SEGMENT_NUMBER     = 2;     /*!< @brief APP5 セグメント内セグメント番号定義のバイト数 */
/*! @} */

/*! APP5 埋め込みデータ ハッシュ値（画像）書き込み位置 */
static const unsigned long APP5_IMAGE_HASH_INSERT_POSITION = 718UL;

/*! APP5 埋め込みデータ ハッシュ値（原画像データ生成日時）書き込み位置 */
static const unsigned long APP5_DATE_HASH_INSERT_POSITION = 783UL;

/*! メタバージョンの定義値 */
static const unsigned short APP5_RMETA_VERSION = 0x0100;

/*! 項目テキスト 1 の ID */
static const unsigned short APP5_RMETA_ITEM_TITLE_ID = 0x0001;

/*! 内容テキスト 128 の ID */
static const unsigned short APP5_RMETA_ITEM_VALUE_ID = 0x0012;

/*! APP5埋め込みデータ */
static const unsigned char APP5_SEGMENT_DATA[] =
{
    0xFF, 0xE5, 0x0D, 0x78, 0x52, 0x4D, 0x45, 0x54, 0x41, 0x00,
    0x4D, 0x4D, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A,
    0x00, 0x14, 0x53, 0x2D, 0x4A, 0x49, 0x53, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x02, 0xAA, 0x89, 0xFC, 0x82, 0xB4, 0x82, 0xF1,
    0x83, 0x60, 0x83, 0x46, 0x83, 0x62, 0x83, 0x4E, 0x92, 0x6C,
    0x81, 0x69, 0x89, 0xE6, 0x91, 0x9C, 0x81, 0x6A, 0x00, 0x89,
    0xFC, 0x82, 0xB4, 0x82, 0xF1, 0x83, 0x60, 0x83, 0x46, 0x83,
    0x62, 0x83, 0x4E, 0x92, 0x6C, 0x81, 0x69, 0x8E, 0x42, 0x89,
    0x65, 0x93, 0xFA, 0x8E, 0x9E, 0x81, 0x6A, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x0A, 0x2A, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,
    0x00, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x52, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/*! メタデータ識別名「RMETA」（終端文字含む） */
static const char IDENTIFIER_RMETA[] =
{
    0x52, 0x4D, 0x45, 0x54, 0x41, 0x00
};

/*! 文字コード定義「S-JIS」（終端文字を含む 8 バイトの配列） */
static const char APP5_CHAR_CODE_SHIFT_JIS[] =
{
    0x53, 0x2D, 0x4A, 0x49, 0x53, 0x00, 0x00, 0x00
};

/*! 「改ざんチェック値（画像）」（終端文字含む） */
static const char APP5_HASH_IMAGE_TITLE_TEXT[] =
{
    0x89, 0xfc, 0x82, 0xb4, 0x82, 0xf1, 0x83, 0x60,
    0x83, 0x46, 0x83, 0x62, 0x83, 0x4e, 0x92, 0x6c,
    0x81, 0x69, 0x89, 0xe6, 0x91, 0x9c, 0x81, 0x6a, 0x00
};

/*! 「改ざんチェック値（撮影日時）」（終端文字含む） */
static const char APP5_HASH_DATE_TITLE_TEXT[] =
{
    0x89, 0xfc, 0x82, 0xb4, 0x82, 0xf1, 0x83, 0x60,
    0x83, 0x46, 0x83, 0x62, 0x83, 0x4e, 0x92, 0x6c,
    0x81, 0x69, 0x8e, 0x42, 0x89, 0x65, 0x93, 0xfa,
    0x8e, 0x9e, 0x81, 0x6a, 0x00
};

/*!
@brief 指定した走査位置より、メタバージョンとして 2 バイト取得する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param seek 指定位置
@return 取得した領域サイズ （見つからなかった、引数不正などで失敗した場合は 0x0000 ）
*/
static unsigned short getMetaVersion(JpegBuffer *src, unsigned long seek)
{
    unsigned short metaVersion = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return metaVersion;
    }

    if(seek + BYTE_SIZE_UNSIGNED_SHORT <= src->_len)
    {
        memcpy(&metaVersion, &(src->_buff[seek]), BYTE_SIZE_UNSIGNED_SHORT);

        /* リトルエンディアンの場合は反転させてビッグエンディアンにする */
        if(getEndian() == JACIC_LITTLE_ENDIAN)
        {
            metaVersion = swapEndian16(metaVersion);
        }
    }

    return metaVersion;
}

/*!
@brief 指定した走査位置より、セグメント番号として 2 バイト取得する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param seek 指定位置
@return 取得した領域サイズ （見つからなかった、引数不正などで失敗した場合は 0x0000 ）
*/
static unsigned short getSegmentNumber(JpegBuffer *src, unsigned long seek)
{
    unsigned short segmentNumber = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return segmentNumber;
    }

    if(seek + BYTE_SIZE_UNSIGNED_SHORT <= src->_len)
    {
        memcpy(&segmentNumber, &(src->_buff[seek]), BYTE_SIZE_UNSIGNED_SHORT);

        /* リトルエンディアンの場合は反転させてビッグエンディアンにする */
        if(getEndian() == JACIC_LITTLE_ENDIAN)
        {
            segmentNumber = swapEndian16(segmentNumber);
        }
    }

    return segmentNumber;
}

/*!
@brief 指定した走査位置より、バイトオーダーからメタデータまでのオフセットサイズとして 2 バイト取得する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param seek 指定位置
@return 取得したオフセットサイズ （見つからなかった、引数不正などで失敗した場合は 0x0000 ）
*/
static unsigned short getRMetaDataOffset(JpegBuffer *src, unsigned long seek)
{
    unsigned short offset = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return offset;
    }

    if(seek + BYTE_SIZE_UNSIGNED_SHORT <= src->_len)
    {
        memcpy(&offset, &(src->_buff[seek]), BYTE_SIZE_UNSIGNED_SHORT);

        /* リトルエンディアンの場合は反転させてビッグエンディアンにする */
        if(getEndian() == JACIC_LITTLE_ENDIAN)
        {
            offset = swapEndian16(offset);
        }
    }

    return offset;
}

/*!
@brief 指定した走査位置より、エントリ数として 2 バイト取得する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param seek 指定位置
@return 取得した領域サイズ （見つからなかった、引数不正などで失敗した場合は 0x0000 ）
*/
static unsigned short getEntryCount(JpegBuffer *src, unsigned long seek)
{
    unsigned short entryCnt = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return entryCnt;
    }

    if(seek + BYTE_SIZE_UNSIGNED_SHORT <= src->_len)
    {
        memcpy(&entryCnt, &(src->_buff[seek]), BYTE_SIZE_UNSIGNED_SHORT);

        /* リトルエンディアンの場合は反転させてビッグエンディアンにする */
        if(getEndian() == JACIC_LITTLE_ENDIAN)
        {
            entryCnt = swapEndian16(entryCnt);
        }
    }

    return entryCnt;
}

/*!
@brief 指定した走査位置より、 ID として 2 バイト取得する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param seek 指定位置
@return 取得した ID （見つからなかった、引数不正などで失敗した場合は 0x0000 ）
*/
static unsigned short getRMetaId(JpegBuffer *src, unsigned long seek)
{
    unsigned short id = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return id;
    }

    if(seek + BYTE_SIZE_UNSIGNED_SHORT <= src->_len)
    {
        memcpy(&id, &(src->_buff[seek]), BYTE_SIZE_UNSIGNED_SHORT);

        /* リトルエンディアンの場合は反転させてビッグエンディアンにする */
        if(getEndian() == JACIC_LITTLE_ENDIAN)
        {
            id = swapEndian16(id);
        }
    }

    return id;
}

/*!
@brief 指定した走査位置より、領域サイズとして 2 バイト取得する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param seek 指定位置
@return 取得した領域サイズ （見つからなかった、引数不正などで失敗した場合は 0x0000 ）
*/
static unsigned short getRMetaSize(JpegBuffer *src, unsigned long seek)
{
    unsigned short size = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return size;
    }

    if(seek + BYTE_SIZE_UNSIGNED_SHORT <= src->_len)
    {
        memcpy(&size, &(src->_buff[seek]), BYTE_SIZE_UNSIGNED_SHORT);

        /* リトルエンディアンの場合は反転させてビッグエンディアンにする */
        if(getEndian() == JACIC_LITTLE_ENDIAN)
        {
            size = swapEndian16(size);
        }
    }

    return size;
}

/*!
@brief 指定した走査位置より、文字コード定義を終端文字含めて 8 バイト取得する。
@details 文字コード定義が見つからなかった、引数不正などで処理に失敗した場合は NULL を返す。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param [out] charCode[] 取得した文字コード定義を格納する文字配列
@param seek 指定位置
*/
static void getCharCodeSet(JpegBuffer *src, char charCode[], unsigned long seek)
{
    /* パラメータチェック */
    if(src == NULL)
    {
        charCode = NULL;
        return;
    }

    if(src->_len < seek + BYTE_SIZE_RMETA_CHARACTER_CODE)
    {
        charCode = NULL;
        return;
    }

    memcpy(charCode, &(src->_buff[seek]), BYTE_SIZE_RMETA_CHARACTER_CODE);
}

/*!
@brief APP5領域を挿入する位置を返す。
@param [in] *src 対象となる JPEG 画像のバイナリ読み込み結果データ構造体
@param [out] *insPos 取得する APP5 領域を挿入する位置情報
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 不正な引数が指定された場合
@retval INCORRECT_EXIF_FORMAT Exif ファイルが不正な形式の場合
@retval APP5_ALREADY_EXISTS APP5 領域が既に存在する場合
*/
static int getApp5InsertPosition(JpegBuffer *src, unsigned long *insPos)
{
    int ret = FUNCTION_SUCCESS;
    unsigned short seg = 0xFFFFU;
    unsigned short len = 0x0000U;
    unsigned long seek = 0U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if(insPos == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    /* Exif スタートマーカー(SOI)チェック */
    seg = getMarkerSegment(src, &seek);

    if(seg != EXIF_MARKER_SOI)
    {
        /*
         * スタートマーカー(SOI)でない場合、
         * 「Exif ファイルフォーマットが不正」としてエラーを返す
         */
        return INCORRECT_EXIF_FORMAT;
    }

    /* セグメントの長さ分、走査位置をずらす */
    seek += BYTE_SIZE_UNSIGNED_SHORT;

    /* 走査位置がデータ長を超える場合 */
    if(src->_len < seek)
    {
        return INCORRECT_EXIF_FORMAT;
    }

    while(1)
    {
        seg = getMarkerSegment(src, &seek);

        /*
         * SOF、DHT、SOS、DQT、DRIのいずれかの場合
         */
        if(seg == EXIF_MARKER_SOF00 ||
                seg == EXIF_MARKER_DHT   ||
                seg == EXIF_MARKER_SOS   ||
                seg == EXIF_MARKER_DQT   ||
                seg == EXIF_MARKER_DRI)
        {

            /* APP5セグメント領域挿入位置を設定 */
            *insPos = seek;
            ret = FUNCTION_SUCCESS;
            break;
        }

        /*
         * セグメントがEOIの場合
         */
        else if(seg == EXIF_MARKER_EOI)
        {
            /*
             * SOSよりも前にEOIが見つかったので、
             * 「Exif ファイルフォーマットが不正」としてエラーを返す
             */
            ret = INCORRECT_EXIF_FORMAT;
            break;
        }

        /*
         * セグメントがAPP5の場合
         */
        else if(seg == EXIF_MARKER_APP05)
        {
            /* APP5セグメントが既に存在するのでエラーを返す */
            ret = APP5_ALREADY_EXISTS;
            break;
        }

        /*
         * 上記以外のセグメントの場合
         */
        else if(((seg >= EXIF_MARKER_SOF01) && (seg <= EXIF_MARKER_SOF03)) ||
                ((seg >= EXIF_MARKER_SOF05) && (seg <= EXIF_MARKER_RST07)) ||
                ((seg >= EXIF_MARKER_DHP)   && (seg <= EXIF_MARKER_COM))   || (seg == EXIF_MARKER_DNL))
        {
            /* 走査位置をセグメントIDの後ろへ移動 */
            seek += BYTE_SIZE_UNSIGNED_SHORT;

            /* セグメントのサイズを取得 */
            len = getAppSize(src, seek);

            /* 走査位置を移動 */
            seek += len;
        }

        /*
         * その他、判別不可能なセグメントの場合
         */
        else
        {
            /* 「Exif ファイルフォーマットが不正」としてエラーを返す */
            ret = INCORRECT_EXIF_FORMAT;
            break;
        }

        /* 走査位置がデータ長を超える場合 */
        if(src->_len < seek)
        {
            ret = INCORRECT_EXIF_FORMAT;
            break;
        }
    }

    return ret;
}

/*!
@brief Exif ファイルに格納されている APP5 領域の存在確認とその開始位置を取得する。
@param [in] *src 対象となる JPEG 画像のバイナリ読み込み結果データ構造体
@param [in, out] *seek 取得する走査開始位置
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER いずれかの引数が NULL, または走査不可能な位置が指定された場合
@retval INCORRECT_EXIF_FORMAT Exif ファイルが不正な形式の場合
@retval APP5_NOT_EXISTS APP1 領域が見つからなかった場合
*/
int checkApp5Exists(JpegBuffer *src, unsigned long *seek)
{
    int ret = FUNCTION_SUCCESS;
    unsigned short len = 0x0000U;

    /* パラメータチェック */
    if(src == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if(seek == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    /* 走査位置がデータ長を超える場合 */
    if(src->_len < *seek)
    {
        return INCORRECT_PARAMETER;
    }

    while(1)
    {
        unsigned short seg = getMarkerSegment(src, seek);

        /*
         * SOF、DHT、SOS、DQT、DRIのいずれかの場合
         */
        if(seg == EXIF_MARKER_SOF00 ||
                seg == EXIF_MARKER_DHT   ||
                seg == EXIF_MARKER_SOS   ||
                seg == EXIF_MARKER_DQT   ||
                seg == EXIF_MARKER_DRI)
        {
            /* APP5領域よりも下に来ているのでエラーを返す */
            ret = APP5_NOT_EXISTS;
            break;
        }

        /*
         * セグメントがEOIの場合
         */
        else if(seg == EXIF_MARKER_EOI)
        {
            /*
             * SOSよりも前にEOIが見つかったので、
             * 「Exif ファイルフォーマットが不正」としてエラーを返す
             */
            ret = INCORRECT_EXIF_FORMAT;
            break;
        }

        /*
         * セグメントがAPP5の場合
         */
        else if(seg == EXIF_MARKER_APP05)
        {
            /* ループを抜ける */
            break;
        }

        /*
         * 上記以外のセグメントの場合
         */
        else if(((seg >= EXIF_MARKER_SOF01) && (seg <= EXIF_MARKER_SOF03)) ||
                ((seg >= EXIF_MARKER_SOF05) && (seg <= EXIF_MARKER_RST07)) ||
                ((seg >= EXIF_MARKER_DHP)   && (seg <= EXIF_MARKER_COM))   || (seg == EXIF_MARKER_DNL))
        {
            /* 走査位置をセグメントIDの後ろへ移動 */
            *seek += BYTE_SIZE_UNSIGNED_SHORT;

            /* セグメントのサイズを取得 */
            len = getAppSize(src, *seek);

            /* 走査位置を移動 */
            *seek += len;
        }

        /*
         * その他、判別不可能なセグメントの場合
         */
        else
        {
            /* 「Exif ファイルフォーマットが不正」としてエラーを返す */
            ret = INCORRECT_EXIF_FORMAT;
            break;
        }

        /* 走査位置がデータ長を超える場合 */
        if(src->_len < *seek)
        {
            /* 「Exif ファイルフォーマットが不正」としてエラーを返す */
            ret = INCORRECT_EXIF_FORMAT;
            break;
        }
    }

    return ret;
}

/*!
@brief ハッシュデータを指定した領域に書き込む。
@param [in, out] **dst 書き込み対象のバイナリデータ構造体
@param [in] *writeData 書き込む内容を示すバイナリデータ構造体
@param insertPosition *dst への書き込み開始位置
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 引数が不正な場合
*/
static int setBinaryData(HashBuffer **dst, HashBuffer *writeData, unsigned long insertPosition)
{
    /* パラメータチェック */
    if(*dst == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if(writeData == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if((*dst)->_len < (insertPosition + writeData->_len))
    {
        /* APP5 領域オーバー */
        return INCORRECT_PARAMETER;
    }

    /* APP5 領域にハッシュ値を埋め込む */
    memcpy((*dst)->_buff + insertPosition, writeData->_buff, writeData->_len);

    return FUNCTION_SUCCESS;
}

/*!
@brief 改ざんチェック用の APP5 領域を JPEG 画像に埋め込んで保存する。
@details JPEG 画像データを先頭から走査していき、最初に見つかった
@details 次のセグメント ( APP6 ～ APP15、DQT、DHT、DRI、SOF、SOS ) の前に、
@details APP5 セグメント領域を追加する。
@remarks ※スマートフォン (HUAWEI P8Lite) で APP1 -> APP0 の順番でセグメントが並んでいる
@remarks   ケースがあったので、上記ルールにて APP5 セグメント領域を追加する。
@param [in] *src JPEG画像のバイナリ読み込み結果データ構造体
@param [in] *imgHash 埋め込むハッシュ値（画像）
@param [in] *dateHash 埋め込むハッシュ値（原画像生成日時）
@param [in] *dst 出力先ファイルパス
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 不正な引数が指定された場合
@retval FILE_OPEN_FAILED ファイルのオープンに失敗
@retval FILE_WRITE_FAILED ファイルへの書き込みに失敗
@retval FILE_CLOSE_FAILED ファイルのクローズに失敗
@retval INCORRECT_EXIF_FORMAT Exif ファイルが不正な形式の場合
@retval APP5_ALREADY_EXISTS APP5 領域が既に存在する場合
@retval OTHER_ERROR メモリの確保に失敗した場合
*/
int writeApp5(JpegBuffer *src, HashBuffer *imgHash, HashBuffer *dateHash, const char *dst)
{
    int ret = FUNCTION_SUCCESS;
    unsigned long insPos = 0UL;
    HashBuffer *app5 = NULL;
    HashBuffer *outBuff = NULL;
    size_t app5Length = sizeof(APP5_SEGMENT_DATA);
    size_t outBuffLength;

    /* パラメータチェック */
    if(src == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if(imgHash == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if(dateHash == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    if(dst == NULL)
    {
        return INCORRECT_PARAMETER;
    }

    outBuffLength = src->_len + app5Length;

    /* APP5セグメント領域データの作成 */
    app5 = (HashBuffer *) malloc(sizeof(HashBuffer *) + app5Length);

    if(app5 == NULL)
    {
        /* メモリ確保失敗 */
        return OTHER_ERROR;
    }

    app5->_len = app5Length;


    /* APP5 領域のゼロクリア */
    memset(app5->_buff, 0x00, app5->_len);

    /* APP5 領域デフォルトデータの作成 */
    memcpy(app5->_buff, APP5_SEGMENT_DATA, app5->_len);

    /* APP5 領域にハッシュ値（画像）を埋め込む */
    setBinaryData(&app5, imgHash, APP5_IMAGE_HASH_INSERT_POSITION);

    /* APP5 領域にハッシュ値（原画像データ生成日時）を埋め込む */
    setBinaryData(&app5, dateHash, APP5_DATE_HASH_INSERT_POSITION);

    /* APP5 の埋め込み位置を走査 */
    ret = getApp5InsertPosition(src, &insPos);

    if(ret != FUNCTION_SUCCESS)
    {
        goto FINALIZE;
    }

    /* APP5 セグメント領域データ分を追加したサイズのバッファを用意 */
    outBuff = (HashBuffer *) malloc(sizeof(HashBuffer *) + outBuffLength);

    if(outBuff == NULL)
    {
        /* メモリ確保失敗 */
        ret = OTHER_ERROR;
        goto FINALIZE;
    }

    outBuff->_len = outBuffLength;

    /* 領域のゼロクリア */
    memset(outBuff->_buff, 0x00, outBuff->_len);

    /* 元データ前半部をコピー */
    memcpy(outBuff->_buff, src->_buff, insPos);

    /* APP5 データをコピー */
    memcpy((outBuff->_buff + insPos), app5->_buff, app5->_len);

    /* 元データ後半部をコピー */
    memcpy((outBuff->_buff + insPos + app5->_len), &(src->_buff[insPos]), src->_len - insPos);

    /* ファイル書き出し */
    ret = writeFile(dst, outBuff->_buff, src->_len + app5->_len);


FINALIZE:
    /* メモリ解放 */

    free(app5);
    app5 = NULL;

    if(outBuff != NULL)
    {
        free(outBuff);
        outBuff = NULL;
    }


    return ret;
}

/*!
@brief APP5 セグメント内のデータ形式が RMETA であるかを確認する。
@param [in] *src JPEG 画像のバイナリ読み込み結果データ構造体
@param [out] *startIndex 走査開始インデックス
@param size 読み込み最大サイズ
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 不正な引数が指定された場合
@retval INCORRECT_EXIF_FORMAT APP5 領域が異なる形式の場合
@retval OTHER_ERROR メモリ確保に失敗した場合
*/
static int checkIdentifierIsRMeta(JpegBuffer *src, unsigned long *startIndex)
{
    /* 識別子が正しいか調べる */
    int ret = checkIdentifier(IDENTIFIER_RMETA, src, startIndex, BYTE_SIZE_RMETA_IDENTIFIER_SIZE);

    if(ret == INCORRECT_IDENTIFIER)
    {
        /* 識別子が違う場合、フォーマットが違う */
        return INCORRECT_APP5_FORMAT;
    }

    return ret;
}

/*!
@brief APP5 領域内で対象の文字列が何番目に格納されているか調べる。
@param *targetItemText チェック対象のタイトル文字列
@param [in] *rMetaItemText 対象となるメタデータ領域を切り取ったデータ構造体
@param [out] *hashItemEntryOrder 取得するハッシュの格納順
@param entryCount 項目の最大エントリ数
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_APP5_FORMAT APP5 領域、またはテキストが不正な形式の場合
@retval HASH_NOT_EXISTS 対象となるテキストが見つからない場合
@retval OTHER_ERROR メモリ確保に失敗した場合
*/
static int seekValueOrder(const char *targetItemText, HashBuffer *rMetaItemText, int *hashItemEntryOrder, unsigned short entryCount)
{
    int ret = HASH_NOT_EXISTS;
    unsigned int i;
    unsigned char *text = NULL;
    unsigned long seek = 0UL;
    size_t maxByteSize = BYTE_SIZE_UNSIGNED_CHAR * rMetaItemText->_len;

    /* 領域の最大数までメモリ確保 */
    text = (unsigned char *) malloc(maxByteSize);

    if(text == NULL)
    {
        /* メモリ確保に失敗 */
        return OTHER_ERROR;
    }

    /* 領域のゼロクリア */
    memset(text, 0x00, maxByteSize);

    /* 初期化 */
    *hashItemEntryOrder = -1;

    /* メタデータを走査する */
    for(i = 0; i < entryCount; ++i)
    {
        int funcRet;

        if(rMetaItemText->_len <= seek)
        {
            /* 走査位置が最大サイズを超えた */
            ret = INCORRECT_APP5_FORMAT;
            break;
        }

        /* テキスト項目格納 */
        funcRet = getByteText(rMetaItemText, text, &seek, rMetaItemText->_len);

        if(funcRet != FUNCTION_SUCCESS)
        {
            /* 取得したテキストが不正 */
            ret = INCORRECT_APP5_FORMAT;
            break;
        }

        /* 探査対象の文字列との比較 */
        if(strcmp((char *)text, targetItemText) == 0)
        {
            /* 現在の番号の内容テキストを探すため格納する */
            *hashItemEntryOrder = i;

            ret = FUNCTION_SUCCESS;
            break;
        }

        /* 取得したテキストの領域をゼロクリア */
        memset(text, 0x00, strlen((char *)text));
    }

    /* メモリ解放 */
    free(text);
    text = NULL;

    return ret;
}

/*!
@brief ハッシュ値を取得する。
@param [in] *rMetaItemText 対象となるメタデータ領域を切り取ったデータ構造体
@param [out] **retHash 取得したハッシュを格納する変数
@param hashItemEntryOrder ハッシュ値の格納順
@param entryCount 項目の最大エントリ数
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 不正な引数が指定された場合
@retval INCORRECT_APP5_FORMAT APP5 領域が不正な形式の場合
@retval INCORRECT_TEXT 指定した項目番号のテキストが不正な場合
*/
static int getHashData(HashBuffer *rMetaItemText, HashBuffer **retHash, int hashItemEntryOrder, unsigned short entryCount)
{
    int ret = FUNCTION_SUCCESS;
    short i;
    unsigned char *hashText = NULL;
    unsigned long seek = 0UL;
    size_t hashMemorySize = sizeof(HashBuffer) + BYTE_SIZE_HASH_LENGTH;
    size_t maxByteSize = sizeof(HashBuffer) + rMetaItemText->_len * BYTE_SIZE_UNSIGNED_CHAR;

    if(hashItemEntryOrder < 0 ||
            entryCount < hashItemEntryOrder)
    {
        /* ハッシュの埋め込み位置を示す引数が 0 以下または最大エントリ数より多い */
        return INCORRECT_PARAMETER;
    }

    /* 領域の最大数までメモリ確保 */
    hashText = (unsigned char *) malloc(maxByteSize);

    if(hashText == NULL)
    {
        /* メモリ確保に失敗 */
        return OTHER_ERROR;
    }

    /* 領域のゼロクリア */
    memset(hashText, 0x00, maxByteSize);

    for(i = 0; i <= hashItemEntryOrder; ++i)
    {
        int funcRet;

        /* テキスト項目格納 */
        funcRet = getByteText(rMetaItemText, hashText, &seek, rMetaItemText->_len);

        if(funcRet != FUNCTION_SUCCESS)
        {
            /* 取得したテキストが不正 */
            ret = INCORRECT_TEXT;
            break;
        }

        if(i == hashItemEntryOrder)
        {
            /* 長さが 0 （終端文字のみ） */
            if(strlen((char *)hashText) == 0)
            {
                /* テキストのフォーマット不正 */
                ret = INCORRECT_TEXT;
                break;
            }

            /* ハッシュの文字列長と長さが合わない */
            else if(strlen((char *)hashText) != BYTE_SIZE_HASH_LENGTH)
            {
                /* テキストのフォーマット不正 */
                ret = INCORRECT_TEXT;
                break;
            }

            /* 領域の確保 */
            *retHash = (HashBuffer *) malloc(hashMemorySize);

            if(*retHash == NULL)
            {
                /* メモリ確保に失敗 */
                ret = OTHER_ERROR;
                break;
            }

            /* 取得した領域をゼロクリア */
            memset(*retHash, 0x00, hashMemorySize);

            /* ハッシュ文字列のコピー */
            memcpy((*retHash)->_buff, hashText, BYTE_SIZE_HASH_LENGTH);
            (*retHash)->_len = BYTE_SIZE_HASH_LENGTH;
            break;
        }

        if(rMetaItemText->_len <= seek)
        {
            /* 走査位置が最大サイズを超えた */
            ret = INCORRECT_APP5_FORMAT;
            break;
        }

        /* 取得したテキストの領域をゼロクリア */
        memset(hashText, 0x00, strlen((char *)hashText));
    }

    /* メモリ解放 */
    free(hashText);
    hashText = NULL;

    /* 処理の途中で失敗した場合のみ retHash を NULL に */
    if(ret != FUNCTION_SUCCESS &&
            *retHash != NULL)
    {
        free(*retHash);
        *retHash = NULL;
    }

    return ret;
}

/*!
@brief 実データから指定したタイトルの項目を取得する。存在しない場合は NULL を設定する。
@param [in] *searchTitle 取得対象の項目テキストタイトル文字列
@param [out] **retItemValue 取得した内容テキストを格納するバイナリデータ構造体
@param [in] *rMetaItemText 取得対象の実データ（項目テキスト）
@param [in] *rMetaItemText128 取得対象の実データ（内容テキスト 128 ）
@param entryCount セグメント内のメタデータ定義数
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 不正な引数が指定された場合
@retval INCORRECT_APP5_FORMAT APP5 領域が不正な形式の場合
@retval HASH_NOT_EXISTS ハッシュ値を示すエントリタイトルが見つからない場合
*/
static int getRMetaItemValue(const char *searchTitle, RMetaItem  *retItemValue, HashBuffer *rMetaItemText, HashBuffer *rMetaItemText128, unsigned short entryCount)
{
    int ret;
    int hashEntryOrder = -1; /* ハッシュ値のアイテム位置 */
    /* 項目テキスト 1 から項目テキストを取得 */
    ret = seekValueOrder(searchTitle, rMetaItemText, &hashEntryOrder, entryCount);

    if(ret == FUNCTION_SUCCESS)
    {
        /* タイトル文字列取得フラグを ON にする */
        retItemValue->titleExistsFlag = JACIC_FLAG_ON;

        /* 内容テキスト 128 から内容テキストの値を取得 */
        ret = getHashData(rMetaItemText128, &(retItemValue->value), hashEntryOrder, entryCount);
    }

    return ret;
}

/*!
@brief RMETA Data を解析してハッシュ値を取得する。
@param [in] *src 対象となる JPEG 画像のバイナリ読み込み結果データ構造体
@param [out] *retImageHash 取得したハッシュ値（画像）を格納する変数
@param [out] *retDateHash 取得したハッシュ値（撮影日時）を格納する変数
@param [in, out] *seek 初期走査位置
@param entryCount エントリ数
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_APP5_FORMAT APP5 領域のフォーマット不正が原因でハッシュ値の取得に失敗した場合
@retval HASH_NOT_EXISTS ハッシュ値が見つからない場合
@retval OTHER_ERROR メモリ確保に失敗した場合
*/
static int getRMetaHashValue(JpegBuffer *src, RMetaItem *retImageHash, RMetaItem *retDateHash, unsigned long *seek, unsigned short entryCount)
{
    int ret = FUNCTION_SUCCESS;
    int funcRet;
    HashBuffer *rMetaItemText1 = NULL;     /* 取得した項目テキスト */
    HashBuffer *rMetaItemText128 = NULL;   /* 取得した内容テキスト */
    size_t memorySize;                     /* 確保するメモリの大きさ */

    while(1)
    {
        unsigned short rMetaItemId;        /* 取得したメタデータ ID */
        unsigned short rMetaItemTextSize;  /* 取得したメタデータの“サイズ定義を除いた”容量 */

        /* RMETA ID を取得 */
        rMetaItemId = getRMetaId(src, *seek);

        /* メタデータの ID 番号定義バイト数だけ走査位置を進める */
        *seek += BYTE_SIZE_RMETA_ITEM_ID;

        /* RMETA 領域サイズを取得（領域サイズ定義の大きさを引く） */
        rMetaItemTextSize = getRMetaSize(src, *seek) - BYTE_SIZE_RMETA_ITEM_SIZE;

        /* RMETA 領域サイズ定義バイト数だけ走査位置を進める */
        *seek += BYTE_SIZE_RMETA_ITEM_SIZE;

        if(rMetaItemId == APP5_RMETA_ITEM_TITLE_ID)
        {
            /* 項目テキスト 1 */
            if(rMetaItemText1 != NULL)
            {
                /* 同じカテゴリのデータが連続して来ているので不正なフォーマットとして終了 */
                ret = INCORRECT_APP5_FORMAT;
                break;
            }

            /* 領域の確保 */
            memorySize = sizeof(HashBuffer) + rMetaItemTextSize;
            rMetaItemText1 = (HashBuffer *) malloc(memorySize);

            if(rMetaItemText1 == NULL)
            {
                /* メモリ確保失敗 */
                ret = OTHER_ERROR;
                break;
            }

            /* 領域のゼロクリア */
            memset(rMetaItemText1, 0x00, memorySize);

            memcpy(rMetaItemText1->_buff, &(src->_buff[*seek]), rMetaItemTextSize);
            rMetaItemText1->_len = rMetaItemTextSize;

            *seek += rMetaItemTextSize;
        }
        else if(rMetaItemId == APP5_RMETA_ITEM_VALUE_ID)
        {
            /* 内容テキスト 128 */
            if(rMetaItemText128 != NULL)
            {
                /* 同じカテゴリのデータが連続して来ているので不正なフォーマットとして終了 */
                ret = INCORRECT_APP5_FORMAT;
                break;
            }

            /* 領域の確保 */
            memorySize = sizeof(HashBuffer) + rMetaItemTextSize;
            rMetaItemText128 = (HashBuffer *) malloc(memorySize);

            if(rMetaItemText128 == NULL)
            {
                /* メモリ確保失敗 */
                ret = OTHER_ERROR;
                break;
            }

            /* 領域のゼロクリア */
            memset(rMetaItemText128, 0x00, memorySize);

            memcpy(rMetaItemText128->_buff, &(src->_buff[*seek]), rMetaItemTextSize);
            rMetaItemText128->_len = rMetaItemTextSize;

            *seek += rMetaItemTextSize;
        }

        /* その他 */
        else if(src->_len < *seek)
        {
            /* 読み込み画像の範囲外に出た場合は不正なフォーマットとして終了 */
            ret = INCORRECT_APP5_FORMAT;
            break;
        }

        /* 両方の領域を取得後に処理を行う */
        if(rMetaItemText1 != NULL &&
                rMetaItemText128 != NULL)
        {
            if(retImageHash->value == NULL)
            {
                /* 項目テキストから「改ざんチェック値（画像）」を取得 */
                funcRet = getRMetaItemValue(APP5_HASH_IMAGE_TITLE_TEXT, retImageHash, rMetaItemText1, rMetaItemText128, entryCount);

                if(funcRet != FUNCTION_SUCCESS &&
                        funcRet != INCORRECT_TEXT && /* ハッシュのタイトルはあるが値が誤り */
                        funcRet != HASH_NOT_EXISTS)  /* ハッシュのタイトル自体が無い */
                {
                    /* 処理を中断 */
                    ret = funcRet;
                    break;
                }
            }

            if(retDateHash->value == NULL)
            {
                /* 項目テキストから「改ざんチェック値（撮影日時）」を取得 */
                funcRet = getRMetaItemValue(APP5_HASH_DATE_TITLE_TEXT, retDateHash, rMetaItemText1, rMetaItemText128, entryCount);

                if(funcRet != FUNCTION_SUCCESS &&
                        funcRet != INCORRECT_TEXT && /* ハッシュのタイトルはあるが値が誤り */
                        funcRet != HASH_NOT_EXISTS)  /* ハッシュのタイトル自体が無い */
                {
                    /* 処理を中断 */
                    ret = funcRet;
                    break;
                }
            }

            if(retImageHash->value != NULL &&
                    retDateHash->value != NULL)
            {
                /* 両方のハッシュ値を取得できている場合は正常終了とする */
                ret = FUNCTION_SUCCESS;
            }
            else
            {
                /* 片方のハッシュ値が見つからない場合はエラーとする */
                ret = HASH_NOT_EXISTS;
            }

            /* ループ処理の終了 */
            break;
        }

    }

    /* メモリ解放 */
    if(rMetaItemText1 != NULL)
    {
        free(rMetaItemText1);
        rMetaItemText1 = NULL;
    }

    if(rMetaItemText128 != NULL)
    {
        free(rMetaItemText128);
        rMetaItemText128 = NULL;
    }

    return ret;
}

/*!
@brief チェック対象画像の APP5 領域からハッシュ値を取得する。
@param [in] *src 対象となる JPEG 画像のバイナリ読み込み結果データ構造体
@param [out] *retImageHash 取得したハッシュ値（画像）を格納する変数
@param [out] *retDateHash 取得したハッシュ値（撮影日時）を格納する変数
@param seek 走査開始位置
@retval FUNCTION_SUCCESS 正常終了
@retval INCORRECT_PARAMETER 不正な引数が指定された場合
@retval INCORRECT_APP5_FORMAT APP5 領域が不正な形式の場合
@retval HASH_NOT_EXISTS ハッシュ値が取得できない場合
@retval OTHER_ERROR メモリ確保に失敗した場合
*/
int getApp5HashValue(JpegBuffer *src, RMetaItem *retImageHash, RMetaItem *retDateHash, unsigned long seek)
{
    int ret = INCORRECT_APP5_FORMAT;
    int nextSegmentNumber = -1;                    /* 次のセグメントの番号：初回は -1 */
    char charCode[BYTE_SIZE_RMETA_CHARACTER_CODE]; /* メタデータ内の文字コード定義 */
    unsigned long byteOrderStartIndex;             /* Byte Order 開始位置 */
    unsigned short byteOrder;                      /* セグメント内のエンディアン定義 */
    unsigned short metaVersion;                    /* セグメント内のバージョン定義 */
    unsigned short segmentNumber;                  /* セグメント番号 */
    unsigned short rMetaDataOffset;                /* Byte Order から数えた RMETAData へのオフセット */
    unsigned short entryCount;                     /* エントリ数 */

    /* パラメータチェック */
    if(src == NULL)
    {
        return INCORRECT_PARAMETER;
    }


    /* 複数 APP5 セグメントに対応するためのループ */
    while(1)
    {
        unsigned long app5EndNextIndex; /* APP5 領域終端“の次の”番地 */
        unsigned short app5Size;        /* APP Size 自身を含むこのセグメントの終端までの長さ */

        /* 画像からAPP5セグメントを検出する */
        ret = checkApp5Exists(src, &seek);

        if(ret != FUNCTION_SUCCESS)
        {
            return ret;
        }

        /* APP5 マーカーのバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_SEGMENT_MARKER;

        /* APP5 セグメントのサイズを取得 */
        app5Size = getAppSize(src, seek);

        /* APP5 セグメントの終端の次の番地を取得 */
        app5EndNextIndex = seek + app5Size;

        /* サイズ定義のバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_SEGMENT_SIZE;

        /* セグメント識別名の取得（RMETAではない場合はこのセグメントを無視して次の APP5 セグメントへ） */
        ret = checkIdentifierIsRMeta(src, &seek);

        if(ret != FUNCTION_SUCCESS)
        {
            /* セグメント識別名が不正な場合、次の APP5 セグメントを探す */
            seek = app5EndNextIndex;
            continue;
        }

        /* セグメント識別子定義のサイズ分走査位置を進める */
        seek += BYTE_SIZE_RMETA_IDENTIFIER_SIZE;

        /* seek の記憶（Byte Order に RMETA Data Offset を足した値が RMETA Data の開始位置となるため） */
        byteOrderStartIndex = seek;

        /* Byte Order の取得（MM（ビッグエンディアン）ではない場合はこのセグメントを無視して次のAPP5セグメントへ） */
        byteOrder = getByteOrder(src, seek);

        if(byteOrder != EXIF_BIG_ENDIAN)
        {
            /* バイトオーダーが不正な場合、次の APP5 セグメントを探す */
            seek = app5EndNextIndex;
            continue;
        }

        /* バイトオーダー定義のバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_ENDIAN;

        /* メタバージョンの取得（0x0100 でない場合はこのセグメントを無視して次の APP5 セグメントへ） */
        metaVersion = getMetaVersion(src, seek);

        if(metaVersion != APP5_RMETA_VERSION)
        {
            /* メタバージョンが不正な場合、次の APP5 セグメントを探す */
            seek = app5EndNextIndex;
            continue;
        }

        /* メタバージョン定義のバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_APP5_META_VERSION;

        /* Segment Number の取得 */
        segmentNumber = getSegmentNumber(src, seek);

        if(nextSegmentNumber != -1 &&
                segmentNumber < (nextSegmentNumber & 0x0000FFFF))
        {
            /*
             * 現在の APP5 セグメント番号が一つ前の APP5 セグメントで定義された
             * 『次の APP5 セグメント番号』より若い場合、エラーとする
             */
            ret = INCORRECT_APP5_FORMAT;
            break;
        }

        /* セグメント番号定義のバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_APP5_SEGMENT_NUMBER;

        /* Next Segment Number の取得（記憶しておく。0x0000の場合はそこで最後のループとする） */
        nextSegmentNumber = getSegmentNumber(src, seek);

        /* セグメント番号定義のバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_APP5_SEGMENT_NUMBER;

        /* RMETA Data Offset の取得 */
        rMetaDataOffset = getRMetaDataOffset(src, seek);

        /* オフセット定義のバイトサイズ分走査位置を進める */
        seek += BYTE_SIZE_RMETA_DATA_OFFSET;

        if(rMetaDataOffset < seek - byteOrderStartIndex)
        {
            /* オフセットを足した走査位置が今まで走査した領域に被る場合 */
            if(nextSegmentNumber == 0x0000)
            {
                /* 次の APP5 セグメントが存在しない場合、そこで終了する */
                ret = INCORRECT_APP5_FORMAT;
                break;
            }
            else
            {
                /* 次の APP5 セグメントを探す */
                seek = app5EndNextIndex;
                continue;
            }
        }

        /* RMETAData 開始位置まで走査位置を移動する */
        seek = byteOrderStartIndex + rMetaDataOffset;

        /* エントリ数の取得（通常 5 または 20 ） */
        entryCount = getEntryCount(src, seek);

        if(entryCount == 0x0000)
        {
            /* エントリ数が不正 */
            if(nextSegmentNumber == 0x0000)
            {
                /* 次の APP5 セグメントが存在しない場合、そこで終了する */
                ret = INCORRECT_APP5_FORMAT;
                break;
            }
            else
            {
                /* 次の APP5 セグメントを探す */
                seek = app5EndNextIndex;
                continue;
            }
        }

        /* エントリ数定義の分だけ走査位置を進める */
        seek += BYTE_SIZE_RMETA_ENTRY_COUNT_VALUE;

        /* 文字コードの取得 */
        getCharCodeSet(src, charCode, seek);

        if(strcmp(charCode, APP5_CHAR_CODE_SHIFT_JIS) != 0)
        {
            /* 文字コードが不正 */
            if(nextSegmentNumber == 0x0000)
            {
                /* 次の APP5 セグメントが存在しない場合、そこで終了する */
                ret = INCORRECT_APP5_FORMAT;
                break;
            }
            else
            {
                /* 次の APP5 セグメントを探す */
                seek = app5EndNextIndex;
                continue;
            }
        }

        /* 文字コード定義の分だけ走査位置を進める */
        seek += BYTE_SIZE_RMETA_CHARACTER_CODE;


        /*
         * RMETA Data を解析し、ハッシュ値を取得する
         * 失敗しても次の APP5 を探すことになっている場合はループを抜けない
         * そうでない場合はエラーとしてループを抜ける
         */
        ret = getRMetaHashValue(src, retImageHash, retDateHash, &seek, entryCount);

        if(ret == FUNCTION_SUCCESS)
        {
            /* ハッシュ値を取得できた場合はループを抜けて正常終了する */
            break;
        }
        else if(nextSegmentNumber == 0x0000)
        {
            /* ハッシュ値が取得できず、次の APP5 セグメントが存在しない場合、エラーとして終了する */
            break;
        }
        else
        {
            /* 次の APP5 セグメントを探す */
            seek = app5EndNextIndex;
        }

    }


    return ret;
}
